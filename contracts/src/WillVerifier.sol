// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title WillVerifier
 * @dev BN254-compatible verifier for ZK will proofs
 * This contract verifies zero-knowledge proofs generated by the Noir will circuit
 */
contract WillVerifier is Ownable {
    constructor() Ownable(msg.sender) {}

    // BN254 field elements
    uint256 constant FIELD_MODULUS =
        0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;

    // UltraHonk proof structure for BN254
    struct Proof {
        // G1 elements (2 * 256 bits each)
        uint256[2] W1; // First witness commitment
        uint256[2] W2; // Second witness commitment
        uint256[2] W3; // Third witness commitment
        uint256[2] W4; // Fourth witness commitment
        // G2 elements (4 * 256 bits each)
        uint256[4] Z; // Zero knowledge commitment
        uint256[4] T1; // Quotient polynomial commitment (first part)
        uint256[4] T2; // Quotient polynomial commitment (second part)
        uint256[4] T3; // Quotient polynomial commitment (third part)
        uint256[4] T4; // Quotient polynomial commitment (fourth part)
        // G1 elements
        uint256[2] W1_omega; // W1 evaluated at omega
        uint256[2] W2_omega; // W2 evaluated at omega
        uint256[2] W3_omega; // W3 evaluated at omega
        uint256[2] W4_omega; // W4 evaluated at omega
        uint256[2] PI_Z; // Public input polynomial
        uint256[2] PI_Z_omega; // Public input polynomial evaluated at omega
        uint256[2] r_0; // Linearization polynomial
    }

    event ProofVerified(
        address indexed verifier,
        uint256[5] publicInputs,
        bool isValid
    );

    /**
     * @dev Verify a ZK proof for will validity
     * @param proof The UltraHonk proof
     * @param publicInputs The public inputs from the circuit (5 elements)
     * @return isValid True if the proof is valid
     */
    function verifyProof(
        Proof memory proof,
        uint256[5] memory publicInputs
    ) public returns (bool isValid) {
        // For now, we'll implement a simplified verification
        // In production, this would include the full UltraHonk verification algorithm

        // Basic checks
        require(publicInputs.length == 5, "Invalid public inputs length");

        // Check that all field elements are within the field modulus
        for (uint256 i = 0; i < 5; i++) {
            require(
                publicInputs[i] < FIELD_MODULUS,
                "Public input exceeds field modulus"
            );
        }

        // Check proof elements are valid
        require(_isValidG1Point(proof.W1), "Invalid W1");
        require(_isValidG1Point(proof.W2), "Invalid W2");
        require(_isValidG1Point(proof.W3), "Invalid W3");
        require(_isValidG1Point(proof.W4), "Invalid W4");
        require(_isValidG2Point(proof.Z), "Invalid Z");

        // For demonstration, we'll do a simplified verification
        // In production, implement the full UltraHonk verification algorithm
        isValid = _simplifiedVerification(proof, publicInputs);

        emit ProofVerified(msg.sender, publicInputs, isValid);

        return isValid;
    }

    /**
     * @dev Simplified verification for demonstration
     * In production, replace with full UltraHonk verification
     */
    function _simplifiedVerification(
        Proof memory proof,
        uint256[5] memory publicInputs
    ) internal pure returns (bool) {
        // Basic consistency checks
        // Check that will_commitment is non-zero
        if (publicInputs[0] == 0) return false;

        // Check that merkle_root is non-zero
        if (publicInputs[1] == 0) return false;

        // Check that totals are reasonable (not all zero)
        if (
            publicInputs[2] == 0 && publicInputs[3] == 0 && publicInputs[4] == 0
        ) {
            return false;
        }

        // Check that proof elements are non-zero
        if (proof.W1[0] == 0 || proof.W1[1] == 0) return false;
        if (proof.W2[0] == 0 || proof.W2[1] == 0) return false;
        if (proof.Z[0] == 0 || proof.Z[1] == 0) return false;

        // For demo purposes, accept proofs that pass basic checks
        // TODO: Implement full UltraHonk verification algorithm
        return true;
    }

    /**
     * @dev Check if a G1 point is valid
     */
    function _isValidG1Point(
        uint256[2] memory point
    ) internal pure returns (bool) {
        return point[0] < FIELD_MODULUS && point[1] < FIELD_MODULUS;
    }

    /**
     * @dev Check if a G2 point is valid
     */
    function _isValidG2Point(
        uint256[4] memory point
    ) internal pure returns (bool) {
        return
            point[0] < FIELD_MODULUS &&
            point[1] < FIELD_MODULUS &&
            point[2] < FIELD_MODULUS &&
            point[3] < FIELD_MODULUS;
    }

    /**
     * @dev Verify proof with public inputs as separate parameters
     * @param proof The UltraHonk proof
     * @param willCommitment The will commitment hash
     * @param merkleRoot The merkle root of beneficiaries
     * @param totalEth Total ETH allocation
     * @param totalUsdc Total USDC allocation
     * @param totalNftCount Total NFT count
     * @return isValid True if the proof is valid
     */
    function verifyWillProof(
        Proof memory proof,
        uint256 willCommitment,
        uint256 merkleRoot,
        uint256 totalEth,
        uint256 totalUsdc,
        uint256 totalNftCount
    ) external returns (bool isValid) {
        uint256[5] memory publicInputs = [
            willCommitment,
            merkleRoot,
            totalEth,
            totalUsdc,
            totalNftCount
        ];

        return verifyProof(proof, publicInputs);
    }

    /**
     * @dev Get the expected public input count
     */
    function getPublicInputCount() external pure returns (uint256) {
        return 5;
    }

    /**
     * @dev Get the field modulus for BN254
     */
    function getFieldModulus() external pure returns (uint256) {
        return FIELD_MODULUS;
    }
}
